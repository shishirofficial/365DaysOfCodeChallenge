Sum of left Leaves
Second Minimum Node In a Binary Tree
class Solution {
public:
  
    int sumOfLeftLeaves(TreeNode* root)
    {
       if(root==NULL)return 0;
        queue<TreeNode*> q;
        q.push(root);
        int sum=0;
        while(q.empty()==false)
        {
            int count=q.size();
            for(int i=0;i<count;i++)
            {
                TreeNode *curr=q.front();
                q.pop();
                if(curr->left)
                {
                    if(curr->left->left==NULL && curr->left->right==NULL)
                    {
                        sum+=curr->left->val;
                    }
                    else
                    {
                        q.push(curr->left);
                    }
                }
                if(curr->right) q.push(curr->right);
            }
        }
       return sum; 
    }
};
................................................................................
class Solution {
public:
    void dfs(TreeNode *root,set<int> &s)
    {
        if(root!=NULL)
        {
            s.insert(root->val);
            dfs(root->left,s);
            dfs(root->right,s);
        }
    }
    int findSecondMinimumValue(TreeNode* root)
    {
        set<int> s;
        dfs(root,s);
        int min1 = root->val;
        long ans=INT_MAX;
        for(int v:s)
        {
            if(min1 < v && v < ans)
            {
                ans=v;
            }
        }
        if(s.size() < 2)
        {
            return -1;
        }
        else
        {
            return ans;
        }
    }
};
